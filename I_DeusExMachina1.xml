<?xml version="1.0" encoding="UTF-8"?>
<implementation>
	<functions>
		SID = "urn:toggledbits-com:serviceId:DeusExMachina1"
		SWITCH_SID = "urn:upnp-org:serviceId:SwitchPower1"
		
		STATE_STANDBY = 0
		STATE_IDLE = 1
		STATE_CYCLE = 2
		STATE_SHUTDOWN = 3
		
		runStamp = 0
		
		local function checkVersion()
			local ui7Check = luup.variable_get(SID, "UI7Check", lul_device) or ""
			if ui7Check == "" then
				luup.variable_set(SID, "UI7Check", "false", lul_device)
				ui7Check = "false"
			end
			if( luup.version_branch == 1 and luup.version_major == 7 and ui7Check == "false") then
				luup.variable_set(SID, "UI7Check", "true", lul_device)
				luup.attr_set("device_json", "D_DeusExMachina1_UI7.json", lul_device)
				luup.reload()
			end
		end
		
		local function getVarNumeric( name, dflt )
			local s = luup.variable_get(SID, name, lul_device)
			if (s == nil or s == "") then return dflt end
			s = tonumber(s, 10)
			if (s == nil) then return dflt end
			return s
		end
		
		local function isEnabled() 
			return getVarNumeric("Enabled", 0)
		end
		
		local function isBedtime()
			local testing = getVarNumeric("TestMode", 0)
			if (testing ~= 0) then luup.log('DeusExMachina: TestMode on') end
			if (not (testing or luup.is_night())) then
				return 1
			end
			-- rigpapa 2016-05-06: keep LightsOutTime in ms for compatibility with
			--                     existing configs; everything else simplified.
			local bedtime_tmp = luup.variable_get(SID, "LightsOutTime", lul_device)
			if (bedtime_tmp == nil) then
				return 1
			end
			local bedtime = tonumber(bedtime_tmp) / 1000
			local date = os.date('*t', luup.sunset())
			local sunset = (date['hour'] * 60 + date['min']) * 60
			if (testing ~= 0) then 
				local s = getVarNumeric( "TestSunset", nil )
				if (s ~= nil) then sunset = tonumber(s,10) * 60 end
				luup.log('DeusExMachina:isBedtime: testing mode sunset time is ' .. tostring(sunset))
			end
			date = os.date('*t')
			local time = (date['hour'] * 60 + date['min']) * 60
			if (testing ~= 0) then			
				luup.log('DeusExMachina: time=' .. tostring(time) .. ', sunset=' .. tostring(sunset) .. ', bedtime=' .. tostring(bedtime))
			end
			local ret = 1;
			if (bedtime &gt; sunset) then
			        -- Case 1: bedtime is after sunset (i.e. between sunset and midnight)
				if (time &gt;= sunset and time &lt; bedtime) then
					ret = 0
				end
			else
			        -- Case 2: bedtime is after midnight
				if (time &gt;= sunset or time &lt; bedtime) then
					ret = 0
				end
			end
			if (testing ~= 0) then luup.log("DeusExMachina:isBedtime() returning " .. tostring(ret)) end
			return ret
		end
		
		local function getMax()
			return getVarNumeric("controlCount", 0)
		end
		
		local function getDeviceId(control)
			return getVarNumeric("control" .. control, nil)
		end
		
		local function turnOffLight()
			local max = getMax()
			if (max &gt; 0) then
				local on = {}
				local count = 0
				for i = 0, max - 1,1 do
					local deviceId = getDeviceId(i)
					if (luup.variable_get(SWITCH_SID, "Status", deviceId) == "1") then
						table.insert(on, deviceId)
						count = count + 1
					end
				end 
				if (count &gt; 0) then
					local change = math.random(1, count)
					luup.call_action(SWITCH_SID, "SetTarget", {newTargetValue="0"}, on[change])
					luup.log("DeusExMachina: Set " .. on[change] .. " to Off")
					-- Return non-zero if there are more lights to turn off
					if (count &gt; 1) then
						return 1
					end
				end
			end
			return 0
		end
		
		function deusEnable()
			luup.log("DeusExMachina: enabling...")
			runStamp = os.time()
			deusStep(runStamp)
		end
		
		function deusDisable()
			local state = getVarNumeric("State", STATE_STANDBY)
			luup.log("DeusExMachina: disabling...")
			if ( state == STATE_CYCLE or state == STATE_SHUTDOWN ) then
				local count = getMax()
				local i
				for i=0, count-1, 1 do
					local deviceid = getDeviceId(i)
					luup.call_action(SWITCH_SID, "SetTarget", { newTargetValue="0" }, deviceid)
				end
			end
			luup.variable_set(SID, "State", STATE_STANDBY, lul_device)
		end
		
		function deusInit(deusDevice)
			luup.log("(DeusExMachina)::(deusInit) : Starting up...")
			
			--check UI version
			checkVersion()
			
			-- Start up if we're enabled
			if (isEnabled() == 1) then
				deusEnable()
			end
		end
		
		function deusStep(stepStampCheck)
			local stepStamp = tonumber(stepStampCheck)
			local sunset = luup.sunset()
			local now = os.time()
			luup.log("DeusExMachina: Checking Iteration " .. stepStampCheck)
			local testing = getVarNumeric("TestMode", 0)
			if (testing ~= 0) then
				-- Note that TestSunset is expressed in MINUTES since midnight
				local s = getVarNumeric("TestSunset", nil)
				if (s ~= nil) then
					local t = tonumber(s, 10)
					local hh = math.floor(t / 60)
					local mm = math.mod(t, 60)
					t = os.date('*t');
					t['hour'] = hh
					t['min'] = mm
					t['sec'] = 0
					sunset = os.time(t)
					if ( sunset &lt;= now ) then sunset = sunset + 86400 end
					luup.log('DeusExMachina:deusStep: testing, next sunset is ' .. tostring(sunset))
				end	
			end
			if (isEnabled() == 1) then
				if (stepStamp == runStamp) then
					local mindelay, maxdelay
					if (isBedtime() == 1) then
						luup.log("DeusExMachina: Lights out time, running off cycle")
						luup.variable_set(SID, "State", STATE_SHUTDOWN, lul_device)
						mindelay = getVarNumeric("MinOffDelay", 300)
						maxdelay = getVarNumeric("MaxOffDelay", 1800)
						if (turnOffLight() == 0) then
							-- No more lights to turn off, arm for next sunset
							luup.variable_set(SID, "State", STATE_IDLE, lul_device)
							local delay = sunset - os.time() + math.random(mindelay,maxdelay)
							luup.log("DeusExMachina: All lights out. Waiting for next sunset in " .. delay .. " seconds")
							luup.call_delay("deusStep", delay, stepStamp, 1)
							return
						end
					else
						luup.log("DeusExMachina: Running toggle cycle")
						luup.variable_set(SID, "State", STATE_CYCLE, lul_device)
						mindelay = getVarNumeric("MinCycleDelay", 300)
						maxdelay = getVarNumeric("MaxCycleDelay", 1800)
						local max = getMax()
						if (max &gt; 0) then
							local change = math.random(0, max - 1)
							local deviceId = getDeviceId(change)
							if (deviceId ~= nil) then
								local status = luup.variable_get(SWITCH_SID, "Status", deviceId)
								if (status == "1") then
									luup.call_action(SWITCH_SID, "SetTarget", {newTargetValue="0"}, deviceId)
									luup.log("DeusExMachina: Set " .. deviceId .. " to Off")
								else
									luup.call_action(SWITCH_SID, "SetTarget", {newTargetValue="1"}, deviceId)
									luup.log("DeusExMachina: Set " .. deviceId .. " to On")
								end
							end
						end
					end
					local delay = math.random(mindelay, maxdelay)
					luup.call_delay("deusStep", delay, stepStamp, 1)
					luup.log("DeusExMachina: Iteration finished. Next iteration in " .. delay .. " seconds")
				else
					luup.log("DeusExMachina: Another iteration started. Skipping Iteration")
				end
			else
				luup.log("DeusExMachina: Not enabled. Skipping Iteration.")
			end
		end
	</functions>
	<startup>deusInit</startup>
	<actionList>
		<action>
			<serviceId>urn:toggledbits-com:serviceId:DeusExMachina1</serviceId>
			<name>SetEnabled</name>
			<job>
				local newEnabledValue = lul_settings.NewEnabledValue
				if (newEnabledValue == "1") then
					luup.variable_set(SID, "Enabled", 1, lul_device)
					deusEnable()
				else
					luup.variable_set(SID, "Enabled", 0, lul_device)
					deusDisable()
				end
			</job>
		</action>
	</actionList>
</implementation>