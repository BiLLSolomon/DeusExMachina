<?xml version="1.0" encoding="UTF-8"?>
<implementation>
    <functions>
        -- -------------------------------------------------------------------------------------------------------------------------
        -- Deus Ex Machina (II)
        -- https://github.com/toggledbits/DeusExMachina
        -- Original code and releases 1.x by Andy Lintner (beowulfe) Version 2.0 and beyond by Patrick Rigney (rigpapa/toggledbits).
        -- A big thanks to Andy for passing the torch so that this great plug-in can live on.
        -- -------------------------------------------------------------------------------------------------------------------------

        SID = "urn:toggledbits-com:serviceId:DeusExMachinaII1"
        SWITCH_TYPE = "urn:schemas-upnp-org:device:BinaryLight:1"
        SWITCH_SID  = "urn:upnp-org:serviceId:SwitchPower1"
        DIMMER_TYPE = "urn:schemas-upnp-org:device:DimmableLight:1"
        DIMMER_SID  = "urn:upnp-org:serviceId:Dimming1"
        DEMVERSION = 20400

        STATE_STANDBY = 0
        STATE_IDLE = 1
        STATE_CYCLE = 2
        STATE_SHUTDOWN = 3

        runStamp = 0

        local function checkVersion()
            local ui7Check = luup.variable_get(SID, "UI7Check", lul_device) or ""
            if ui7Check == "" then
                luup.variable_set(SID, "UI7Check", "false", lul_device)
                ui7Check = "false"
            end
            if( luup.version_branch == 1 and luup.version_major == 7 and ui7Check == "false") then
                luup.variable_set(SID, "UI7Check", "true", lul_device)
                luup.attr_set("device_json", "D_DeusExMachinaII1_UI7.json", lul_device)
                luup.reload()
            end
        end

        -- Get numeric variable, or return default value if not set or blank
        local function getVarNumeric( name, dflt )
            local s = luup.variable_get(SID, name, lul_device)
            if (s == nil or s == "") then return dflt end
            s = tonumber(s, 10)
            if (s == nil) then return dflt end
            return s
        end

        -- Delete a variable (if we can... read on...)
        local function deleteVar( name, devid )
            if (devid == nil) then devid = luup.device end
            -- Interestingly, setting a variable to nil with luup.variable_set does nothing interesting; too bad, it
            -- could have been used to delete variables, since a later get would yield nil anyway. But it turns out
            -- that using the variableget Luup request with no value WILL delete the variable.
            local req = "http://127.0.0.1:3480/data_request?id=variableset&amp;DeviceNum=" .. tostring(devid) .. "&amp;serviceId=" .. SID .. "&amp;Variable=" .. name .. "&amp;Value="
            -- luup.log("DeusExMachinaII::deleteVar(" .. name .. "): req=" .. tostring(req))
            local status, result = luup.inet.wget(req)
            -- luup.log("DeusExMachinaII::deleteVar(" .. name .. "): status=" .. tostring(status) .. ", result=" .. tostring(result))
        end

        -- Shortcut function to return state of Enabled variable
        local function isEnabled()
            return ( getVarNumeric("Enabled", 0) ~= 0 )
        end

        local function isActiveHouseMode()
            -- Fetch our mask bits that tell us what modes we operate in. If 0, we're not checking house mode.
            local modebits = getVarNumeric("HouseModes", 0)
            if (modebits ~= 0) then
                -- Get the current house mode. There seems to be some disharmony in the correct way to go
                -- about this, but the method (uncommented) below works.
                -- local currentMode = luup.attr_get("Mode") -- alternate method
                local currentMode
                local status
                status, currentMode = luup.inet.wget("http://127.0.0.1:3480/data_request?id=variableget&amp;Variable=Mode", 2)
                if status ~= 0 then
                    luup.log("DeusExMachinaII::isActiveHouseMode(): can't get current house mode, status=" .. tostring(status))
                    currentMode = 0
                end

                -- Check to see if house mode bits are non-zero, and if so, apply current mode as mask.
                -- If bit is set (current mode is in the bitset), we can run, otherwise skip.
                local bit = require("bit")
                -- Get the current house mode (1=Home,2=Away,3=Night,4=Vacation)
                currentMode = math.pow(2, tonumber(currentMode,10))
                if (bit.band(modebits, currentMode) == 0) then
                    luup.log('DeusExMachinaII::isActiveHouseMode(): Current mode bit ' .. string.format("0x%x", currentMode) .. ' not in set ' .. string.format("0x%x", modebits))
                    return false -- not active in this mode
                end
            end
            return true -- default is we're active in the current house mode
        end

        -- Get a random delay from two state variables. Error check.
        function getRandomDelay(minStateName,maxStateName,defMin,defMax)
            if defMin == nil then defMin = 300 end
            if defMax == nil then defMax = 1800 end
            local mind = getVarNumeric(minStateName, defMin)
            if mind &lt; 1 then mind = 1 elseif mind &gt; 7200 then mind = 7200 end
            local maxd = getVarNumeric(maxStateName, defMax)
            if maxd &lt; 1 then maxd = 1 elseif maxd &gt; 7200 then maxd = 7200 end
            if maxd &lt; mind then maxd = mind end
            return math.random( mind, maxd )
        end

        -- Get sunset time in minutes since midnight. May override for test mode value.
        function getSunset()
            -- Figure out our sunset time. Note that if we make this inquiry after sunset, MiOS
            -- returns the time of tomorrow's sunset. But, that's not different enough from today's
            -- that it really matters to us, so go with it.
            local sunset = luup.sunset()
            local testing = getVarNumeric("TestMode", 0)
            if (testing ~= 0) then
                local m = getVarNumeric( "TestSunset", nil ) -- units are minutes since midnight
                if (m ~= nil) then
                    -- Sub in our test sunset time
                    local t = os.date('*t', sunset)
                    t['hour'] = math.floor(m / 60)
                    t['min'] = math.floor(m % 60)
                    t['sec'] = 0
                    sunset = os.time(t)
                end
                luup.log('DeusExMachinaII::getSunset(): testing mode sunset override ' .. tostring(m) .. ', as time is ' .. tostring(sunset))
            end
            if (sunset &lt;= os.time()) then sunset = sunset + 86400 end
            return sunset
        end

        function getSunsetMSM()
            local t = os.date('*t', getSunset());
            return t['hour']*60 + t['min']
        end

        -- DEM cycles lights between sunset and the user-specified off time. This function returns 0
        -- if the current time is between sunset and off; otherwise 1. Note that all times are reduced
        -- to minutes-since-midnight units.
        local function isBedtime()
            local testing = getVarNumeric("TestMode", 0)
            if (testing ~= 0) then luup.log('DeusExMachinaII::isBedtime(): TestMode is on') end

            -- Establish the lights-out time
            local bedtime = 1439 -- that's 23:59 in minutes since midnight (default)
            local bedtime_tmp = luup.variable_get(SID, "LightsOut", lul_device)
            if (bedtime_tmp ~= nil) then
                bedtime_tmp = tonumber(bedtime_tmp,10)
                if (bedtime_tmp &gt;= 0 and bedtime_tmp &lt; 1440) then bedtime = bedtime_tmp end
            end

            -- Figure out our sunset time.
            local sunset = getSunsetMSM()

            -- And the current time.
            local date = os.date('*t')
            local time = date['hour'] * 60 + date['min']

            -- Figure out if we're betweeen sunset and lightout (ret=0) or not (ret=1)
            if (testing ~= 0) then
                luup.log('DeusExMachinaII::isBedtime(): times (mins since midnight) are now=' .. tostring(time) .. ', sunset=' .. tostring(sunset) .. ', bedtime=' .. tostring(bedtime))
            end
            local ret = 1 -- guilty until proven innocent
            if (bedtime &gt; sunset) then
                    -- Case 1: bedtime is after sunset (i.e. between sunset and midnight)
                if (time &gt;= sunset and time &lt; bedtime) then
                    ret = 0
                end
            else
                    -- Case 2: bedtime is after midnight
                if (time &gt;= sunset or time &lt; bedtime) then
                    ret = 0
                end
            end
            if (testing ~= 0) then luup.log("DeusExMachinaII::isBedtime(): returning " .. tostring(ret)) end
            return ret
        end

        -- Take a string and split it around sep, returning table (indexed) of substrings
        -- For example abc,def,ghi becomes t[1]=abc, t[2]=def, t[3]=ghi
        -- Returns: table of values, count of values (integer ge 0)
        local function split(s, sep)
            local t = {}
            local n = 0
            if (#s == 0) then return t,n end -- empty string returns nothing
            local i,j
            local k = 1
            repeat
                i, j = string.find(s, sep or "%s*,%s*", k)
                if (i == nil) then
                    table.insert(t, string.sub(s, k, -1))
                    n = n + 1
                    break
                else
                    table.insert(t, string.sub(s, k, i-1))
                    n = n + 1
                    k = j + 1
                end
            until k &gt; string.len(s)
            return t, n
        end

        -- Return true if a specified scene has been run (i.e. on the list)
        local function isSceneOn(spec)
            local stateList = luup.variable_get(SID, "ScenesRunning", lul_device) or ""
            for i in string.gfind(stateList, "[^,]+") do
                if (i == spec) then return true end
            end
            return false
        end

        -- Mark or unmark a scene as having been run
        local function updateSceneState(spec, isOn)
            local stateList = luup.variable_get(SID, "ScenesRunning", lul_device) or ""
            local i
            local t = {}
            for i in string.gfind(stateList, "[^,]+") do
                t[i] = 1
            end
            if (isOn) then
                t[spec] = 1
            else
                t[spec] = nil
            end
            stateList = ""
            for i in pairs(t) do stateList = stateList .. "," .. tostring(i) end
            luup.variable_set(SID, "ScenesRunning", string.sub(stateList, 2, -1), lul_device)
        end

        -- Run "final" scene, if defined. This scene is run after all other devices have been
        -- turned off.
        local function runFinalScene()
            local scene  = getVarNumeric("FinalScene", nil)
            if (scene ~= nil) then
                luup.log("DeusExMachina::runFinalScene(): running final scene " .. tostring(scene))
                luup.call_action("urn:micasaverde-com:serviceId:HomeAutomationGateway1", "RunScene", { SceneNum=scene }, 0)
            end
        end

        -- Get the list of controlled devices from our device state, parse to table of device IDs.
        local function getDeviceList()
            local s = luup.variable_get(SID, "Devices", lul_device) or ""
            return split(s)
        end

        -- Light on or off? Returns boolean
        local function isDeviceOn(devid)
            local first = string.upper(string.sub(devid, 1, 1))
            if (first == "S") then
luup.log("DeusExMachinaII::isDeviceOn(): handling scene spec " .. devid)
                return isSceneOn(devid)
            end

            -- Handle as switch or dimmer
luup.log("DeusExMachinaII::isDeviceOn(): handling device spec " .. devid)
            local r = tonumber(string.match(devid, '^%d+'), 10)
luup.log("DeusExMachinaII::isDeviceOn(): device number seems to be " .. tostring(r))
            local val = "0"
            if (luup.devices[r] ~= nil) then
                local t = luup.variable_get(DIMMER_SID, "LoadLevelStatus", r)
                if (t == nil) then
                    t = luup.variable_get(SWITCH_SID, "Status", r)
                    if (t == nil) then
                        luup.log("DeusExMachinaII::isDeviceOn(): device " .. tostring(devid) .. " unknown device type")
                        return nil
                    else
                        val =  luup.variable_get(SWITCH_SID, "Status", r)
                    end
                else
                    val = luup.variable_get(DIMMER_SID, "LoadLevelStatus", r)
                end
            else
                luup.log("DeusExMachinaII::isDeviceOn(): device spec " .. tostring(devid) .. " device " .. tostring(r) .. ", device not found in luup.devices")
                return false
            end
            return val ~= "0"
        end

        -- Control device. Device is a string, expected to be a pure integer (in which case the device is assumed to be a switch or dimmer),
        -- or a string in the form Sxx:yy, in which case xx is an "on" scene to run, and yy is an "off" scene to run.
        local function deviceControl(devid, turnOn)
            luup.log("DeusExMachinaII::deviceControl(): devid=" .. tostring(devid) .. ", turnOn=" .. tostring(turnOn))
            local first = string.upper(string.sub(devid, 1, 1))
            if first == "S" then
luup.log("DeusExMachinaII::deviceControl(): handling scene spec " .. devid)
                i, j, onScene, offScene = string.find(string.sub(devid, 2), "(%d+)-(%d+)")
                if (i == nil) then
                    luup.log("DeusExMachina::deviceControl(): malformed scene spec=" .. devid)
                    return
                end
                onScene = tonumber(onScene, 10)
                offScene = tonumber(offScene, 10)
                if luup.scenes[onScene] == nil or luup.scenes[offScene] == nil then
                    -- Both on scene and off scene must exist (defensive).
                    luup.log("DeusExMachinaII::deviceControl(): one or both of the scenes in " .. tostring(devid) .. " not found in luup.scenes!")
                    return
                end
luup.log("DeusExMachinaII::deviceControl(): on scene is " .. tostring(onScene) .. ", off scene is " .. tostring(offScene))
                local targetScene
                if (turnOn) then targetScene = onScene else targetScene = offScene end
                luup.call_action("urn:micasaverde-com:serviceId:HomeAutomationGateway1", "RunScene", { SceneNum=targetScene }, 0)
                updateSceneState(devid, turnOn)
            else
                local lvl = 100
                local k = string.find(devid, '=')
                if k ~= nil then
                    _, _, devid, lvl = string.find(devid, "(%d+)=(%d+)")
                    lvl = tonumber(lvl, 10)
                end
                devid = tonumber(devid, 10)
luup.log("DeusExMachinaII::deviceControl(): handling device " .. tostring(devid) .. ", level " .. tostring(lvl))
                if luup.devices[devid] == nil then
                    luup.log("DeusExMachinaII::deviceControl(): device " .. tostring(devid) .. " not found in luup.devices");
                    return
                end
                -- Level for all types is 0 if turning device off
                if not turnOn then lvl = 0 end
                local t = luup.variable_get(DIMMER_SID, "LoadLevelTarget", devid)
                if (t == nil) then
                    t = luup.variable_get(SWITCH_SID, "Status", devid)
                    if (t == nil) then
                        luup.log("DeusExMachinaII: deviceControl(): can't determine device type of devspec=" .. devid)
                    else
                        -- Handle as SwitchPower1
                        if turnOn then lvl = 1 end
luup.log("DeusExMachinaII: deviceControl(): handling " .. devid .. " as binary light, setting target to " .. lvl)
                        luup.call_action(SWITCH_SID, "SetTarget", {newTargetValue=lvl}, devid)
                    end
                else
                    -- Handle as Dimming1
luup.log("DeusExMachinaII: deviceControl(): handling " .. devid .. " as dimmer, setting load level to " .. lvl)
                    luup.call_action(DIMMER_SID, "SetLoadLevelTarget", {newLoadlevelTarget=lvl}, devid) -- note odd case inconsistency
                end
            end
        end

        -- Turn off a light, if any is on. Returns 1 if there are more lights to turn off; otherwise 0.
        local function turnOffLight()
            local devs, max
            devs, max = getDeviceList()
            if (max &gt; 0) then
                local i
                local on = {}
                local n = 0
                for i = 1,max do
                    local devOn = isDeviceOn(devs[i])
                    if (devOn ~= nil and devOn) then
                        table.insert(on, devs[i])
                        n = n + 1
                    end
                end
                if (n &gt; 0) then
                    i = math.random(1, n)
                    deviceControl(on[i], false)
                    luup.log("DeusExMachinaII::turnOffLight(): turned " .. tostring(on[i]) .. " OFF, " .. tostring(n-1) .. " devices still on.")
                    if (n &gt; 1) then
                        return true -- there are still lights to turn off
                    end
                end
            end
            return false -- no more lights to turn off
        end

        -- Turn off all lights as fast as we can. Transition through SHUTDOWN state during,
        -- in case user has any triggers connected to that state. The caller must immediately
        -- set the next state when this function returns (expected would be STANDBY or IDLE).
        function clearLights()
            local devs, count
            devs, count = getDeviceList()
            luup.variable_set(SID, "State", STATE_SHUTDOWN, lul_device)
            while count &gt; 0 do
                deviceControl(devs[count], false)
                count = count - 1
            end
            runFinalScene()
        end

        -- runOnce() looks to see if a core state variable exists; if not, a one-time initialization
        -- takes place. For us, that means looking to see if an older version of Deus is still
        -- installed, and copying its config into our new config. Then disable the old Deus.
        local function runOnce()
            local s = luup.variable_get(SID, "Enabled", lul_device)
            if (s == nil) then
                luup.log("DeusExMachinaII::runOnce(): Enabled variable not found, running...")
                -- See if there are variables from older version of DEM
                -- Start by finding the old Deus device, if there is one...
                local i, olddev
                olddev = -1
                for i,v in pairs(luup.devices) do
                    if (v.device_type == "urn:schemas-futzle-com:device:DeusExMachina:1") then
                        luup.log("DeusExMachinaII::runOnce(): Found old Deus Ex Machina device #" .. tostring(i))
                        olddev = i
                        break
                    end
                end
                if (olddev &gt; 0) then
                    -- We found an old Deus device, copy its config into our new state variables
                    local oldsid = "urn:futzle-com:serviceId:DeusExMachina1"
                    s = luup.variable_get(oldsid, "LightsOutTime", olddev)
                    if (s ~= nil) then
                        local n = tonumber(s,10) / 60000
                        luup.variable_set(SID, "LightsOut", n, lul_device)
                        deleteVar("LightsOutTime", lul_device)
                    end
                    s = luup.variable_get(oldsid, "controlCount", olddev)
                    if (s ~= nil) then
                        local n = tonumber(s, 10)
                        local k
                        local t = {}
                        for k = 1,n do
                            s = luup.variable_get(oldsid, "control" .. tostring(k-1), olddev)
                            if (s ~= nil) then
                                table.insert(t, s)
                            end
                        end
                        s = table.concat(t, ",")
                        luup.variable_set(SID, "Devices", s, lul_device)
                        deleteVar("controlCount", lul_device)
                    end

                    -- Finally, turn off old Deus
                    luup.call_action(oldsid, "SetEnabled", { NewEnabledValue = "0" }, olddev)
                end

                -- Set up some other default config
                luup.variable_set(SID, "MinCycleDelay", "300", lul_device)
                luup.variable_set(SID, "MaxCycleDelay", "1800", lul_device)
                luup.variable_set(SID, "MinOffDelay", "60", lul_device)
                luup.variable_set(SID, "MaxOffDelay", "300", lul_device)
                luup.variable_set(SID, "LightsOut", 1439, lul_device)
                luup.variable_set(SID, "Enabled", "0", lul_device)
                luup.variable_set(SID, "Version", DEMVERSION, lul_device)
            end

            -- Consider per-version changes.
            s = getVarNumeric("Version", 0)
            if (s &lt; 20300) then
                -- v2.3: LightsOutTime (in milliseconds) deprecated, now using LightsOut (in minutes since midnight)
                luup.log("DeusExMachinaII::runOnce(): updating config, version " .. tostring(s) .. " &lt; 20300")
                s = luup.variable_get(SID, "LightsOut", lul_device)
                if (s == nil) then
                    s = getVarNumeric("LightsOutTime") -- get pre-2.3 variable
                    if (s == nil) then
                        luup.variable_set(SID, "LightsOut", 1439, lul_device) -- default 23:59
                    else
                        luup.variable_set(SID, "LightsOut", tonumber(s,10) / 60000, lul_device) -- conv ms to minutes
                    end
                end
                deleteVar("LightsOutTime", lul_device)
            end

            -- Update version last.
            luup.variable_set(SID, "Version", DEMVERSION, lul_device)
        end

        -- Enable DEM by setting a new cycle stamp and calling an initial cycle directly.
        function deusEnable()
            luup.log("DeusExMachinaII::deusEnable(): enabling...")
            luup.variable_set(SID, "ScenesRunning", "", lul_device) -- start with a clean slate
            runStamp = os.time()
            deusStep(runStamp)
        end

        -- Disable DEM and go to standby state. If we are currently cycling (as opposed to idle/waiting for sunset),
        -- turn off any controlled lights that are on.
        function deusDisable()
            local s = getVarNumeric("State", STATE_STANDBY)
            luup.log("DeusExMachinaII::deusDisable(): disabling...")
            if ( s == STATE_CYCLE or s == STATE_SHUTDOWN ) then
                clearLights()
            end
            luup.variable_set(SID, "State", STATE_STANDBY, lul_device)
        end

        -- Initialize.
        function deusInit(deusDevice)
            luup.log("DeusExMachinaII::deusInit(): Version 2.4RC1 (2016-09-25), starting up...")

            -- One-time stuff
            runOnce()

            --check UI version
            checkVersion()

            -- Start up if we're enabled
            if (isEnabled()) then
                deusEnable()
            else
                deusDisable()
            end
        end

        -- Run a cycle. If we're in "bedtime" (i.e. not between our cycle period between sunset and stop),
        -- then we'll shut off any lights we've turned on and queue another run for the next sunset. Otherwise,
        -- we'll toggled one of our controlled lights, and queue (random delay, but soon) for another cycle.
        -- The shutdown of lights also occurs randomly, but can (through device state/config) have different
        -- delays, so the lights going off looks more "natural" (i.e. not all at once just slamming off).
        function deusStep(stepStampCheck)
            local stepStamp = tonumber(stepStampCheck)
            luup.log("DeusExMachinaII::deusStep(): wakeup, stamp " .. stepStampCheck)
            if (stepStamp ~= runStamp) then
                luup.log("DeusExMachinaII::deusStep(): stamp mismatch, another thread running. Bye!")
                return
            end
            if (not isEnabled()) then
                luup.log("DeusExMachinaII::deusStep(): not enabled, no more work for this thread...")
                return
            end

            -- Get next sunset as seconds since midnight (approx)
            local sunset = getSunset()

            local currentState = getVarNumeric("State", 0)
            if (currentState == STATE_STANDBY or currentState == STATE_IDLE) then
                luup.log("DeusExMachinaII::deusStep(): run in state "
                    .. tostring(currentState)
                    .. ", lightsout=" .. tostring(luup.variable_get(SID, "LightsOut", lul_device))
                    .. ", sunset=" .. tostring(sunset)
                    .. ", os.time=" .. tostring(os.time())
                )
                luup.log("+ long="
                    .. tostring(luup.longitude)
                    .. ", lat=" .. tostring(luup.latitude)
                    .. ", tz=" .. tostring(luup.timezone)
                    .. ", city=" .. tostring(luup.city)
                    .. ", luup.sunset=" .. tostring(luup.sunset())
                    .. ", version=" .. tostring(luup.version)
                )
            end

            local inActiveTimePeriod = true
            if (isBedtime() ~= 0) then
                luup.log("DeusExMachinaII::deusStep(): in lights out time")
                inActiveTimePeriod = false
            end
			
            -- Get going...
            local nextCycleDelay = 300 -- a default value to keep us out of hot water
			if (currentState == STATE_STANDBY and not inActiveTimePeriod) then
					-- Transition from STATE_STANDBY (i.e. we're enabling) in the inactive period.
					-- Go to IDLE and delay for next sunset.
                    luup.log("DeusExMachinaII::deusStep(): transitioning to IDLE from STANDBY, waiting for next sunset...");
                    nextCycleDelay = sunset - os.time() + getRandomDelay("MinOffDelay", "MaxOffDelay", 60, 300)
                    luup.variable_set(SID, "State", STATE_IDLE, lul_device)
			elseif (not isActiveHouseMode()) then
                -- Not in an active house mode. If we're not STANDBY or IDLE, turn everything back off and go to IDLE.
                if (currentState ~= STATE_IDLE) then
                    luup.log("DeusExMachinaII::deusStep(): transitioning to IDLE, not in an active house mode.");
                    if (currentState ~= STATE_STANDBY) then clearLights() end -- turn off lights quickly unless transitioning from STANDBY
                    luup.variable_set(SID, "State", STATE_IDLE, lul_device)
                else
                    luup.log("DeusExMachinaII::deusStep(): IDLE in an inactive house mode; waiting for mode change.");
                end

                -- Figure out how long to delay. If we're lights-out, delay to next sunset. Otherwise, short delay
                -- to re-check house mode, which could change at any time, so we must deal with it.
                if (inActiveTimePeriod) then
                    nextCycleDelay = 300
                else
                    nextCycleDelay = sunset - os.time() + getRandomDelay("MinOffDelay", "MaxOffDelay", 60, 300)
                end
            elseif (not inActiveTimePeriod) then
                luup.log("DeusExMachinaII::deusStep(): running off cycle")
                luup.variable_set(SID, "State", STATE_SHUTDOWN, lul_device)
                if (not turnOffLight()) then
                    -- No more lights to turn off
                    runFinalScene()
                    luup.variable_set(SID, "State", STATE_IDLE, lul_device)
                    nextCycleDelay = sunset - os.time() + getRandomDelay("MinOffDelay", "MaxOffDelay", 60, 300)
                    luup.log("DeusExMachina::deusStep(): all lights out; now IDLE, setting delay to restart cycling at next sunset")
                else
                    nextCycleDelay = getRandomDelay("MinOffDelay", "MaxOffDelay", 60, 300)
                end
            else
                -- Fully active. Find a random device to control and control it.
                luup.log("DeusExMachinaII::deusStep(): running toggle cycle")
                luup.variable_set(SID, "State", STATE_CYCLE, lul_device)
                nextCycleDelay = getRandomDelay("MinCycleDelay", "MaxCycleDelay")
                local devs, max
                devs, max = getDeviceList()
                if (max &gt; 0) then
                    local change = math.random(1, max)
                    local devspec = devs[change]
                    if (devspec ~= nil) then
                        local s = isDeviceOn(devspec)
                        if (s ~= nil) then
                            if (s) then
                                deviceControl(devspec, false)
                                luup.log("DeusExMachinaII::deusStep(): set " .. devspec .. " to OFF")
                            else
                                deviceControl(devspec, true)
                                luup.log("DeusExMachinaII::deusStep(): set " .. devspec .. " to ON")
                            end
                        end
                    end
                else
                    luup.log("DeusExMachinaII:deusStep(): no devices to control")
                end
            end

            -- Arm for next cycle
            if nextCycleDelay ~= nil then
                luup.log("DeusExMachinaII::deusStep(): cycle finished, next in " .. nextCycleDelay .. " seconds")
                if nextCycleDelay &lt; 1 then nextCycleDelay = 60 end
                luup.call_delay("deusStep", nextCycleDelay, stepStamp, 1)
            else
                luup.log("DeusExMachinaII::deusStep(): nil nextCycleDelay, next cycle not scheduled!");
            end
        end
    </functions>
    <startup>deusInit</startup>
    <actionList>
        <action>
            <serviceId>urn:toggledbits-com:serviceId:DeusExMachinaII1</serviceId>
            <name>SetEnabled</name>
            <job>
                local newEnabledValue = lul_settings.NewEnabledValue
                if (newEnabledValue == "1") then
                    luup.variable_set(SID, "Enabled", 1, lul_device)
                    deusEnable()
                else
                    luup.variable_set(SID, "Enabled", 0, lul_device)
                    deusDisable()
                end
            </job>
        </action>
    </actionList>
</implementation>
