<?xml version="1.0" encoding="UTF-8"?>
<implementation>
    <functions>
        -- -------------------------------------------------------------------------------------------------------------------------
        -- Deus Ex Machina (II)
        -- https://github.com/toggledbits/DeusExMachina
        -- Original code and releases 1.x by Andy Lintner (beowulfe) Version 2.0 and beyond by Patrick Rigney (rigpapa/toggledbits).
        -- A big thanks to Andy for passing the torch so that this great plug-in can live on.
        -- -------------------------------------------------------------------------------------------------------------------------
        
        SID = "urn:toggledbits-com:serviceId:DeusExMachinaII1"
        SWITCH_TYPE = "urn:schemas-upnp-org:device:BinaryLight:1"
        SWITCH_SID  = "urn:upnp-org:serviceId:SwitchPower1"
        DIMMER_TYPE = "urn:schemas-upnp-org:device:DimmableLight:1"
        DIMMER_SID  = "urn:upnp-org:serviceId:Dimming1"
        DEMVERSION = 20302
        
        STATE_STANDBY = 0
        STATE_IDLE = 1
        STATE_CYCLE = 2
        STATE_SHUTDOWN = 3
        
        runStamp = 0
        
        local function checkVersion()
            local ui7Check = luup.variable_get(SID, "UI7Check", lul_device) or ""
            if ui7Check == "" then
                luup.variable_set(SID, "UI7Check", "false", lul_device)
                ui7Check = "false"
            end
            if( luup.version_branch == 1 and luup.version_major == 7 and ui7Check == "false") then
                luup.variable_set(SID, "UI7Check", "true", lul_device)
                luup.attr_set("device_json", "D_DeusExMachinaII1_UI7.json", lul_device)
                luup.reload()
            end
        end
        
        -- Get numeric variable, or return default value if not set or blank
        local function getVarNumeric( name, dflt )
            local s = luup.variable_get(SID, name, lul_device)
            if (s == nil or s == "") then return dflt end
            s = tonumber(s, 10)
            if (s == nil) then return dflt end
            return s
        end
        
        -- Delete a variable (if we can... read on...)
        local function deleteVar( name, devid )
            if (devid == nil) then devid = luup.device end
            -- Interestingly, setting a variable to nil with luup.variable_set does nothing interesting; too bad, it 
            -- could have been used to delete variables, since a later get would yield nil anyway. But it turns out
            -- that using the variableget Luup request with no value WILL delete the variable.
            local req = "http://127.0.0.1:3480/data_request?id=variableset&amp;DeviceNum=" .. tostring(devid) .. "&amp;serviceId=" .. SID .. "&amp;Variable=" .. name .. "&amp;Value="
            -- luup.log("DeusExMachinaII::deleteVar(" .. name .. "): req=" .. tostring(req))
            local status, result = luup.inet.wget(req)
            -- luup.log("DeusExMachinaII::deleteVar(" .. name .. "): status=" .. tostring(status) .. ", result=" .. tostring(result))
        end
        
        -- Shortcut function to return state of Enabled variable
        local function isEnabled() 
            return getVarNumeric("Enabled", 0)
        end
        
        -- DEM cycles lights between sunset and the user-specified off time. This function returns 0
        -- if the current time is between sunset and off; otherwise 1. Note that all times are reduced
        -- to minutes-since-midnight units.
        local function isBedtime()
            local testing = getVarNumeric("TestMode", 0)
            if (testing ~= 0) then luup.log('DeusExMachinaII::isBedtime(): TestMode is on') end

            -- Establish the lights-out time
            local bedtime = 1439 -- that's 23:59 in minutes since midnight (default)
            local bedtime_tmp = luup.variable_get(SID, "LightsOut", lul_device) 
            if (bedtime_tmp ~= nil) then
                bedtime_tmp = tonumber(bedtime_tmp,10)
                if (bedtime_tmp &gt;= 0 and bedtime_tmp &lt; 1440) then bedtime = bedtime_tmp end
            end
            
            -- Figure out our sunset time. Note that if we make this inquiry after sunset, MiOS
            -- returns the time of tomorrow's sunset. But, that's not different enough from today's
            -- that it really matters to us, so go with it.
            local date = os.date('*t', luup.sunset())
            local sunset = date['hour'] * 60 + date['min']
            if (testing ~= 0) then 
                local s = getVarNumeric( "TestSunset", nil )
                if (s ~= nil) then sunset = s end
                luup.log('DeusExMachinaII::isBedtime(): testing mode sunset override time is ' .. tostring(sunset))
            end
            
            -- And the current time.
            date = os.date('*t')
            local time = date['hour'] * 60 + date['min']
            
            -- Figure out if we're betweeen sunset and lightout (ret=0) or not (ret=1)
            if (testing ~= 0) then          
                luup.log('DeusExMachinaII:isBedtime(): times (mins since midnight) are now=' .. tostring(time) .. ', sunset=' .. tostring(sunset) .. ', bedtime=' .. tostring(bedtime))
            end
            local ret = 1 -- guilty until proven innocent
            if (bedtime &gt; sunset) then
                    -- Case 1: bedtime is after sunset (i.e. between sunset and midnight)
                if (time &gt;= sunset and time &lt; bedtime) then
                    ret = 0
                end
            else
                    -- Case 2: bedtime is after midnight
                if (time &gt;= sunset or time &lt; bedtime) then
                    ret = 0
                end
            end
            if (testing ~= 0) then luup.log("DeusExMachinaII::isBedtime(): returning " .. tostring(ret)) end
            return ret
        end

        -- Take a string and split it around sep, returning table (indexed) of substrings
        -- For example abc,def,ghi becomes t[1]=abc, t[2]=def, t[3]=ghi
        -- Returns: table of values, count of values (integer >= 0)
        local function split(s, sep)
            local t = {}
            local n = 0
            if (#s == 0) then return t,n end -- empty string returns nothing
            local i,j
            local k = 1
            repeat
                i, j = string.find(s, sep or "%s*,%s*", k)
                if (i == nil) then
                    table.insert(t, string.sub(s, k, -1))
                    n = n + 1
                    break
                else
                    table.insert(t, string.sub(s, k, i-1))
                    n = n + 1
                    k = j + 1
                end
            until k &gt; string.len(s)
            return t, n
        end
        
        -- Return true if a specified scene has been run (i.e. on the list)
        local function isSceneOn(spec)
            local stateList = luup.variable_get(SID, "ScenesRunning", lul_device) or ""
            for i in string.gfind(stateList, "[^,]+") do
                if (i == spec) then return true end
            end
            return false
        end
        
        -- Mark or unmark a scene as having been run
        local function updateSceneState(spec, isOn)
            local stateList = luup.variable_get(SID, "ScenesRunning", lul_device) or ""
            local i
            local t = {}
            for i in string.gfind(stateList, "[^,]+") do
                t[i] = 1
            end
            if (isOn) then
                t[spec] = 1
            else
                t[spec] = nil
            end
            stateList = ""
            for i in pairs(t) do stateList = stateList .. "," .. tostring(i) end
            luup.variable_set(SID, "ScenesRunning", string.sub(stateList, 2, -1), lul_device)
        end
        
        -- Run "final" scene, if defined. This scene is run after all other devices have been
        -- turned off.
        local function runFinalScene()
            local scene  = getVarNumeric("FinalScene", nil)
            if (scene ~= nil) then
                luup.log("DeusExMachina::runFinalScene(): running final scene " .. tostring(scene))
                luup.call_action("urn:micasaverde-com:serviceId:HomeAutomationGateway1", "RunScene", { SceneNum=scene }, 0)
            end
        end
        
        -- Get the list of controlled devices from our device state, parse to table of device IDs.
        local function getDeviceList()
            local s = luup.variable_get(SID, "Devices", lul_device) or ""
            return split(s)
        end
        
        -- Light on or off? Returns boolean
        local function isDeviceOn(devid)
            local first = string.upper(string.sub(devid, 1, 1))
            if (first == "S") then
luup.log("DEMII::isDeviceOn(): handling scene spec " .. devid)          
                return isSceneOn(devid)
            end
            
            -- Handle as switch or dimmer
luup.log("DEMII::isDeviceOn(): handling device spec " .. devid)         
            local r = tonumber(string.match(devid, '%d+'), 10)
luup.log("DEMII::isDeviceOn(): device number seems to be " .. tostring(r))          
            local val = "0"
            if (luup.devices[r] ~= nil) then
                local t = luup.devices[r].device_type
                if (t == SWITCH_TYPE) then
                    val =  luup.variable_get(SWITCH_SID, "Status", r)
                elseif (t == DIMMER_TYPE) then
                    val = luup.variable_get(DIMMER_SID, "LoadLevelStatus", r)
                else
                    luup.log("DeusExMachinaII::isDeviceOn(): device " .. tostring(devid) .. " unknown device_type " .. tostring(t))
                    return false
                end
            else
                luup.log("DeusExMachinaII::isDeviceOn(): device spec " .. tostring(devid) .. " device " .. tostring(r) .. ", device not found in luup.devices")
                return false
            end
            return val ~= "0"
        end
        
        -- Control device. Device is a string, expected to be a pure integer (in which case the device is assumed to be a switch or dimmer), 
        -- or a string in the form Sxx:yy, in which case xx is an "on" scene to run, and yy is an "off" scene to run.
        local function deviceControl(devid, turnOn)
            luup.log("DeusExMachinaII::deviceControl(): devid=" .. tostring(devid) .. ", turnOn=" .. tostring(turnOn))
            local first = string.upper(string.sub(devid, 1, 1))
            if first == "S" then
luup.log("DEMII::deviceControl(): handling scene spec " .. devid)           
                i, j, onScene, offScene = string.find(string.sub(devid, 2), "(%d+)-(%d+)")
                if (i == nil) then
                    luup.log("DeusExMachina::deviceControl(): malformed scene spec=" .. devid)
                    return
                end
                onScene = tonumber(onScene, 10)
                offScene = tonumber(offScene, 10)
                if luup.scenes[onScene] == nil or luup.scenes[offScene] == nil then
                    -- Both on scene and off scene must exist (defensive).
                    luup.log("DeusExMachinaII::deviceControl(): one or both of the scenes in " .. tostring(devid) .. " not found in luup.scenes!")
                    return
                end
luup.log("DEMII::deviceControl(): on scene is " .. tostring(onScene) .. ", off scene is " .. tostring(offScene))
                local targetScene
                if (turnOn) then targetScene = onScene else targetScene = offScene end
                luup.call_action("urn:micasaverde-com:serviceId:HomeAutomationGateway1", "RunScene", { SceneNum=targetScene }, 0)
                updateSceneState(devid, turnOn)
            else
                local lvl = 100
                local k = string.find(devid, '=')
                if k ~= nil then
                    _, _, devid, lvl = string.find(devid, "(%d+)=(%d+)")
                    lvl = tonumber(lvl, 10)
                end
                devid = tonumber(devid, 10)
luup.log("DEMII::deviceControl(): handling device " .. tostring(devid) .. ", level " .. tostring(lvl))              
                if luup.devices[devid] == nil then
                    luup.log("DeusExMachinaII::deviceControl(): device " .. tostring(devid) .. " not found in luup.devices");
                    return
                end
                local t = luup.devices[devid].device_type
                if not turnOn then 
                    lvl = 0 
                end
                if (t == DIMMER_TYPE) then
                    luup.call_action(DIMMER_SID, "SetLoadLevelTarget", {newLoadlevelTarget=lvl}, devid) -- note odd case inconsistency
                elseif (t == SWITCH_TYPE) then
                    if turnOn then lvl = 1 end
                    luup.call_action(SWITCH_SID, "SetTarget", {newTargetValue=lvl}, devid)
                else
                    luup.log("DeusExMachinaII: deviceControl(): can't determine device type of devspec=" .. devid)
                end 
            end
        end

        -- Turn off a light, if any is on. Returns 1 if there are more lights to turn off; otherwise 0.
        local function turnOffLight()
            local devs, max
            devs, max = getDeviceList()
            if (max &gt; 0) then
                local i
                local on = {}
                local n = 0
                for i = 1,max do
                    if (isDeviceOn(devs[i])) then
                        table.insert(on, devs[i])
                        n = n + 1
                    end
                end
                if (n &gt; 0) then
                    i = math.random(1, n)
                    deviceControl(on[i], false)
                    luup.log("DeusExMachinaII::turnOffLight(): turned " .. tostring(on[i]) .. " OFF, " .. tostring(n-1) .. " devices still on.")
                    if (n &gt; 1) then
                        return 1
                    end
                end
            end
            return 0
        end
        
        -- runOnce() looks to see if a core state variable exists; if not, a one-time initialization
        -- takes place. For us, that means looking to see if an older version of Deus is still 
        -- installed, and copying its config into our new config. Then disable the old Deus.
        local function runOnce()
            local s = luup.variable_get(SID, "Enabled", lul_device)
            if (s == nil) then
                luup.log("DeusExMachinaII::runOnce(): Enabled variable not found, running...")
                -- See if there are variables from older version of DEM
                -- Start by finding the old Deus device, if there is one...
                local i, olddev
                olddev = -1
                for i,v in pairs(luup.devices) do
                    if (v.device_type == "urn:schemas-futzle-com:device:DeusExMachina:1") then
                        luup.log("DeusExMachinaII::runOnce(): Found old Deus Ex Machina device #" .. tostring(i))
                        olddev = i
                        break
                    end
                end
                if (olddev &gt; 0) then
                    -- We found an old Deus device, copy its config into our new state variables
                    local oldsid = "urn:futzle-com:serviceId:DeusExMachina1"
                    s = luup.variable_get(oldsid, "LightsOutTime", olddev)
                    if (s ~= nil) then
                        local n = tonumber(s,10) / 60000
                        luup.variable_set(SID, "LightsOut", n, lul_device)
                        deleteVar("LightsOutTime", lul_device)
                    end
                    s = luup.variable_get(oldsid, "controlCount", olddev)
                    if (s ~= nil) then
                        local n = tonumber(s, 10)
                        local k
                        local t = {}
                        for k = 1,n do
                            s = luup.variable_get(oldsid, "control" .. tostring(k-1), olddev)
                            if (s ~= nil) then
                                table.insert(t, s)
                            end
                        end
                        s = table.concat(t, ",")
                        luup.variable_set(SID, "Devices", s, lul_device)
                        deleteVar("controlCount", lul_device)
                    end
                    
                    -- Finally, turn off old Deus
                    luup.call_action(oldsid, "SetEnabled", { NewEnabledValue = "0" }, olddev)
                end
                
                -- Set up some other default config
                luup.variable_set(SID, "MinCycleDelay", "300", lul_device)
                luup.variable_set(SID, "MaxCycleDelay", "1800", lul_device)
                luup.variable_set(SID, "MinOffDelay", "60", lul_device)
                luup.variable_set(SID, "MaxOffDelay", "300", lul_device)
                luup.variable_set(SID, "LightsOut", 1439, lul_device)
                luup.variable_set(SID, "Enabled", "0", lul_device)
                luup.variable_set(SID, "Version", DEMVERSION, lul_device)
            end

            -- Consider per-version changes.
            -- v2.3: LightsOutTime (in milliseconds) deprecated, now using LightsOut (in minutes since midnight)
            s = getVarNumeric("Version", 0)
            if (s &lt; DEMVERSION) then
                luup.log("DeusExMachinaII::runOnce(): updating config, version " .. tostring(s) .. " &lt; " .. DEMVERSION)
                s = luup.variable_get(SID, "LightsOut", lul_device)
                if (s == nil) then
                    s = getVarNumeric("LightsOutTime") -- get pre-2.2 variable
                    if (s == nil) then
                        luup.variable_set(SID, "LightsOut", 1439, lul_device) -- default 23:59
                    else
                        luup.variable_set(SID, "LightsOut", tonumber(s,10) / 60000, lul_device) -- conv ms to minutes
                    end
                end
                deleteVar("LightsOutTime", lul_device)
                
                -- Update version last.
                luup.variable_set(SID, "Version", DEMVERSION, lul_device)
            end
        end
        
        -- Enable DEM by setting a new cycle stamp and calling an initial cycle directly.
        function deusEnable()
            luup.log("DeusExMachinaII::deusEnable(): enabling...")
            luup.variable_set(SID, "ScenesRunning", "", lul_device) -- start with a clean slate
            runStamp = os.time()
            deusStep(runStamp)
        end

        -- Disable DEM and go to standby state. If we are currently cycling (as opposed to idle/waiting for sunset),
        -- turn off any controlled lights that are on.
        function deusDisable()
            local state = getVarNumeric("State", STATE_STANDBY)
            luup.log("DeusExMachinaII::deusDisable(): disabling...")
            if ( state == STATE_CYCLE or state == STATE_SHUTDOWN ) then
                local devs, count
                devs, count = getDeviceList()
                while count &gt; 0 do
                    deviceControl(devs[count], false)
                    count = count - 1
                end
            end
            luup.variable_set(SID, "State", STATE_STANDBY, lul_device)
        end
        
        -- Initialize.
        function deusInit(deusDevice)
            luup.log("DeusExMachinaII::deusInit(): Version 2.3 (2016-08-20), starting up...")
            
            -- One-time stuff
            runOnce()
            
            --check UI version
            checkVersion()
            
            -- Start up if we're enabled
            if (isEnabled() == 1) then
                deusEnable()
            else
                deusDisable()
            end
        end
        
        -- Run a cycle. If we're in "bedtime" (i.e. not between our cycle period between sunset and stop),
        -- then we'll shut off any lights we've turned on and queue another run for the next sunset. Otherwise,
        -- we'll toggled one of our controlled lights, and queue (random delay, but soon) for another cycle.
        -- The shutdown of lights also occurs randomly, but can (through device state/config) have different
        -- delays, so the lights going off looks more "natural" (i.e. not all at once just slamming off).
        function deusStep(stepStampCheck)
            local stepStamp = tonumber(stepStampCheck)
            luup.log("DeusExMachinaII::deusStep(): wakeup, stamp " .. stepStampCheck)
            if (stepStamp ~= runStamp) then
                luup.log("DeusExMachinaII::deusStep(): another thread running, skipping")
                return
            end
            if (isEnabled() ~= 1) then
                luup.log("DeusExMachinaII::deusStep(): not enabled, skipping")
                return
            end

            local modebits = getVarNumeric("HouseModes", 0)
            -- local currentMode = luup.attr_get("Mode")
            local currentMode
            local status
            status, currentMode = luup.inet.wget("http://127.0.0.1:3480/data_request?id=variableget&amp;Variable=Mode",0)
            
            local currentState = getVarNumeric("State", 0)
            if (currentState == 0 or currentState == 1) then
                luup.log("DeusExMachinaII:deusStep(): run in state " 
                    .. tostring(currentState)
                    .. ", modebits=" .. tostring(modebits)
                    .. ", currentMode=" .. tostring(currentMode)
                    .. ", lightsout=" .. tostring(luup.variable_get(SID, "LightsOut", lul_device))
                    .. ", luup.sunset=" .. tostring(luup.sunset())
                    .. ", os.time=" .. tostring(os.time())
                )
                luup.log("+++ longitude="
                    .. tostring(luup.longitude)
                    .. ", latitude=" .. tostring(luup.latitude)
                    .. ", timezone=" .. tostring(luup.timezone)
                    .. ", city=" .. tostring(luup.city)
                    .. ", version=" .. tostring(luup.version)
                )
            end

            local runCycle = 1
            
            -- Check to see if house mode bits are non-zero, and if so, apply current mode as mask.
            -- If bit is set (current mode is in the bitset), we can run, otherwise skip.
            if (modebits ~= 0) then
                local bit = require("bit")
                -- Get the current house mode (1=Home,2=Away,3=Night,4=Vacation)
                currentMode = math.pow(2, tonumber(currentMode,10))
                if (bit.band(modebits, currentMode) == 0) then
                    luup.log('DeusExMachinaII::deusStep(): Current mode bit ' .. string.format("0x%x", currentMode) .. ' not in set ' .. string.format("0x%x", modebits))
                    runCycle = 0
                end
            end
            
            if (runCycle and isBedtime() ~= 0) then
                luup.log("DeusExMachinaII::deusStep(): lights out time")
                runCycle = 0
            end
            
            -- See if we're in test mode. If so, compute possible sunset override (debug)
            local mindelay, maxdelay
            local sunset = luup.sunset()
            local now = os.time()
            local testing = getVarNumeric("TestMode", 0)
            if (testing ~= 0) then
                -- Note that TestSunset is expressed in MINUTES since midnight
                local s = getVarNumeric("TestSunset", nil)
                if (s ~= nil) then
                    local t = tonumber(s, 10)
                    local hh = math.floor(t / 60)
                    local mm = math.mod(t, 60)
                    t = os.date('*t')
                    t['hour'] = hh
                    t['min'] = mm
                    t['sec'] = 0
                    sunset = os.time(t)
                    if ( sunset &lt;= now ) then sunset = sunset + 86400 end
                    luup.log('DeusExMachinaII::deusStep(): TestMode is on, next sunset is ' .. tostring(sunset) .. " (" .. tostring(sunset-os.time()) .. " from now)")
                end 
            end

            -- See if we've crossed the lights-out time
            if (runCycle == 0) then
                luup.log("DeusExMachinaII::deusStep(): running off cycle")
                luup.variable_set(SID, "State", STATE_SHUTDOWN, lul_device)
                mindelay = getVarNumeric("MinOffDelay", 60)
                maxdelay = getVarNumeric("MaxOffDelay", 300)
                if (turnOffLight() == 0) then
                    -- No more lights to turn off, arm for next sunset
                    runFinalScene()
                    luup.variable_set(SID, "State", STATE_IDLE, lul_device)
                    local delay = sunset - os.time() + math.random(mindelay,maxdelay)
                    luup.log("DeusExMachina::deusStep(): all lights out; waiting for next sunset in " .. delay)
                    luup.call_delay("deusStep", delay, stepStamp, 1)
                    return
                end
            else
                luup.log("DeusExMachinaII::deusStep(): running toggle cycle")
                luup.variable_set(SID, "State", STATE_CYCLE, lul_device)
                mindelay = getVarNumeric("MinCycleDelay", 300)
                maxdelay = getVarNumeric("MaxCycleDelay", 1800)
                local devs, max
                devs, max = getDeviceList()
                if (max &gt; 0) then
                    local change = math.random(1, max)
                    local devspec = devs[change]
                    if (devspec ~= nil) then
                        if (isDeviceOn(devspec)) then
                            deviceControl(devspec, false)
                            luup.log("DeusExMachinaII::deusStep(): set " .. devspec .. " to OFF")
                        else
                            deviceControl(devspec, true)
                            luup.log("DeusExMachinaII::deusStep(): set " .. devspec .. " to ON")
                        end
                    end
                else
                    luup.log("DeusExMachinaII:deusStep(): no devices to control")
                end
            end
            
            -- Arm for next cycle
            -- PHR??? Should we sure delay doesn't roll past LightsOut? Does it matter?
            local delay = math.random(mindelay, maxdelay)
            luup.call_delay("deusStep", delay, stepStamp, 1)
            luup.log("DeusExMachinaII::deusStep(): cycle finished, next in " .. delay .. " seconds")
        end
    </functions>
    <startup>deusInit</startup>
    <actionList>
        <action>
            <serviceId>urn:toggledbits-com:serviceId:DeusExMachinaII1</serviceId>
            <name>SetEnabled</name>
            <job>
                local newEnabledValue = lul_settings.NewEnabledValue
                if (newEnabledValue == "1") then
                    luup.variable_set(SID, "Enabled", 1, lul_device)
                    deusEnable()
                else
                    luup.variable_set(SID, "Enabled", 0, lul_device)
                    deusDisable()
                end
            </job>
        </action>
    </actionList>
</implementation>
